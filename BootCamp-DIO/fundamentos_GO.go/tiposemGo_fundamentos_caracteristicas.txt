Tipos em Go: Fundamentos e CaracterÃ­sticas
Em Go, os tipos definem a natureza dos dados que uma variÃ¡vel pode armazenar e as operaÃ§Ãµes que podem ser realizadas com ela. Vamos explorar detalhadamente o sistema de tipos em Go:

ğŸ—ï¸ Tipos BÃ¡sicos (Primitivos)
Go possui vÃ¡rios tipos bÃ¡sicos prÃ©-definidos:

1. Tipos NumÃ©ricos
Inteiros:

go
var i int       // Tamanho depende da plataforma (32 ou 64 bits)
var i8 int8     // -128 a 127
var i16 int16   // -32768 a 32767
var i32 int32   // -2Â³Â¹ a 2Â³Â¹-1
var i64 int64   // -2â¶Â³ a 2â¶Â³-1
Sem sinal:

go
var u uint       // Similar a int, mas sem sinal
var u8 uint8     // 0 a 255
var u16 uint16   // 0 a 65535
var u32 uint32   // 0 a 2Â³Â²-1
var u64 uint64   // 0 a 2â¶â´-1
var b byte       // alias para uint8
Ponto flutuante:

go
var f32 float32 // IEEE-754 32-bit
var f64 float64 // IEEE-754 64-bit (recomendado)
Complexos:

go
var c64 complex64   // float32 real e imaginary parts
var c128 complex128 // float64 real e imaginary parts
2. Tipos Textuais
go
var s string  // SequÃªncia de bytes (UTF-8 por padrÃ£o)
var r rune    // alias para int32, representa um cÃ³digo Unicode
3. Tipos Booleanos
go
var b bool    // true ou false


ğŸ¢ Tipos Compostos
1. Arrays (Tamanho fixo)
go
var arr [3]int        // Array de 3 inteiros
arrLit := [3]int{1, 2, 3} // Inicializado
2. Slices (Tamanho dinÃ¢mico)
go
var slice []int               // DeclaraÃ§Ã£o
slice := make([]int, 3)       // CriaÃ§Ã£o com make
slice := []int{1, 2, 3}       // InicializaÃ§Ã£o
subSlice := slice[1:3]        // "Fatia" do slice
3. Maps (DicionÃ¡rios)
go
var m map[string]int          // DeclaraÃ§Ã£o
m = make(map[string]int)      // InicializaÃ§Ã£o
m := map[string]int{"a": 1}   // Literal
4. Structs (Estruturas)
go
type Pessoa struct {
    Nome string
    Idade int
}

p := Pessoa{"JoÃ£o", 30}
p := Pessoa{Nome: "JoÃ£o", Idade: 30} // Estilo nomeado


ğŸ”„ Tipos de ReferÃªncia
Ponteiros:

go
var p *int        // Ponteiro para int
x := 10
p = &x            // & obtÃ©m o endereÃ§o
*p = 20           // * dereferencia
FunÃ§Ãµes (sÃ£o tipos de primeira classe):

go
var f func(int) int
f = func(x int) int { return x * x }
Interfaces:

go
type Leitor interface {
    Leia() string
}


ğŸ”„ ConversÃ£o de Tipos
Go requer conversÃ£o explÃ­cita entre tipos:

go
var i int = 42
var f float64 = float64(i)
var u uint = uint(f)

// Erro comum:
// result := f + i  // InvÃ¡lido!
result := f + float64(i)  // Correto
ğŸ§© Tipos Personalizados
VocÃª pode criar novos tipos baseados em tipos existentes:

go
type Celsius float64
type ID string

var temp Celsius = 36.6
var userID ID = "usr_123"


ğŸš¨ Comportamentos Importantes
Zero Values: Cada tipo tem um valor padrÃ£o quando declarado:

0 para numÃ©ricos

false para booleanos

"" para strings

nil para ponteiros, slices, maps, channels e funÃ§Ãµes

Comparabilidade:

Tipos comparÃ¡veis: bÃ¡sicos, ponteiros, channels, interfaces, structs/arrays contendo apenas tipos comparÃ¡veis

Tipos nÃ£o comparÃ¡veis: slices, maps, funÃ§Ãµes

Type Inference (InferÃªncia de Tipos):

go
x := 42      // int
y := 3.14    // float64
z := "texto" // string


ğŸ’¡ Quando Usar Cada Tipo
Para desempenho crÃ­tico: Escolha tipos especÃ­ficos (int32 vs int)

Para interoperabilidade: Use tipos explÃ­citos ao trabalhar com redes/arquivos

Para cÃ³digo genÃ©rico: Interfaces ou generics (Go 1.18+)

ğŸ“š DocumentaÃ§Ã£o Oficial
Para mais detalhes, consulte a especificaÃ§Ã£o de tipos em Go.